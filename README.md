# ZK Score Verification with zkVerify

This project demonstrates how to use Zero-Knowledge Proofs to verify gaming scores and submit them to the [zkVerify](https://zkverify.io/) network.

## Project Structure
- `circuits/`: Contains the `score_prover.circom` circuit and compiled artifacts
- `scripts/`: Integration scripts for zkVerify CLI workflow
- `server.ts`: Production backend server for proof submission
- `test.html`: Browser-based proof generation UI

## Prerequisites
1. **Circom Compiler**: Install from [circom.io](https://docs.circom.io/getting-started/installation/).
2. **SnarkJS**: Installed via `npm install`.
3. **zkVerify Account**: You need a Substrate-compatible wallet (like Polkadot.js) and some testnet VFY tokens.

## Security Architecture

This project implements a three-layer security model to ensure score authenticity and prevent fraud:

### 1. Replay Protection (sessionId)
- **Purpose**: Prevents proof replay attacks
- **How it works**: Each game session generates a unique sessionId that's included in the proof
- **Requirements**: Must be unique per session and never reused
- **Example**: `Date.now().toString() + Math.floor(Math.random() * 1000).toString()` or UUID

Without sessionId, an attacker could reuse a valid proof multiple times to inflate their score on a leaderboard.

### 2. Identity Binding (playerAddress)
- **Purpose**: Binds the proof to a specific player's wallet address
- **Format**: Hex address starting with `0x...`
- **Example**: `0x1234567890abcdef1234567890abcdef12345678`

Without playerAddress, any player could submit another player's valid proof as their own.

### 3. Secret Commitment (secret)
- **Purpose**: Proves the player knows a private secret for their address
- **Format**: Text, number, or hex value (never revealed publicly)
- **How it works**: The circuit computes `Poseidon(secret, playerAddress)` and includes it in public signals
- **Example**: `my-secret-key-12345` or `0x1a2b3c4d5e6f...`

The secret proves that the proof was generated by the legitimate owner of that wallet address. Without this, anyone could generate proofs for any address.

## Circuit Constraints

The `score_prover.circom` circuit enforces the following constraints:

1. **Score Bounds**: Each individual score must be < 1001
   - Prevents unrealistic or manipulated score values
   - Example: If a player inputs score=9999, proof generation fails

2. **Sum Consistency**: `scores[0] + scores[1] + scores[2] + scores[3] + scores[4] === claimedTotal`
   - Ensures the claimed total actually matches the individual scores
   - Example: `[100, 200, 150, 300, 250]` must have `claimedTotal = 1000`

3. **Identity Commitment**: `Poseidon(secret, playerAddress) === secretCommitment`
   - Proves the prover knows the secret for this specific address
   - Output `secretCommitment` is the hash result

### Quick Reference: Circuit Inputs/Outputs

| Name | Type | Public/Private | Description | Example |
|------|------|----------------|-------------|---------|
| **Inputs** | | | | |
| `scores[5]` | number[] | Private | Individual level scores (0-1000) | `[100, 200, 150, 300, 250]` |
| `secret` | bigint | Private | Player's secret key (never revealed) | `123456789` or `"my-secret"` |
| `claimedTotal` | bigint | Public | Sum of all scores | `1000` |
| `sessionId` | bigint | Public | Unique session identifier | `1736543210123` |
| `playerAddress` | bigint | Public | Player's wallet address | `0x1234...5678` |
| **Outputs** | | | | |
| `secretCommitment` | bigint | Public | Hash(secret, playerAddress) | `0xabc...def` |
| `isValid` | bigint | Public | Always equals 1 | `1` |

## Public vs Private Inputs

The `score_prover.circom` circuit distinguishes between inputs that remain hidden and those that are publicly visible:

| Name | Type | Privacy | Description |
|------|------|----------|-------------|
| **Private Inputs** | | | |
| `scores[5]` | number[] | ‚ùå Private | Individual level scores - never revealed to anyone |
| `secret` | bigint | ‚ùå Private | Player's secret key - proves identity without disclosure |
| **Public Inputs** | | | |
| `claimedTotal` | bigint | ‚úÖ Public | Sum of scores - visible on leaderboard |
| `sessionId` | bigint | ‚úÖ Public | Unique session identifier - prevents replay attacks |
| `playerAddress` | bigint | ‚úÖ Public | Player's wallet address - binds proof to owner |
| **Public Outputs** | | | |
| `secretCommitment` | bigint | ‚úÖ Public | Hash(secret, playerAddress) - verifies secret knowledge |
| `isValid` | bigint | ‚úÖ Public | Always equals 1 - indicates proof validity |

### Why This Separation Matters

**Private inputs enable true zero-knowledge:**
- Scores can be proven valid without revealing individual level performance
- Secret can prove identity without exposing actual secret value

**Public inputs enable verification:**
- Leaderboard needs `claimedTotal` to display scores
- Backend needs `sessionId` to prevent replay attacks
- `playerAddress` ensures the proof belongs to the right player
- `secretCommitment` allows anyone to verify the secret is correct without knowing it

## Circuit Code Walkthrough

Let's examine how the `score_prover.circom` circuit enforces game rules and security constraints.

### Circuit Structure

```circom
pragma circom 2.1.0;

include "../node_modules/circomlib/circuits/poseidon.circom";
include "../node_modules/circomlib/circuits/comparators.circom";

template ScoreVerifier(n) {
    // ... signals and logic
}
```

## Monitoring zkVerify Transactions

The zkVerify library provides an EventEmitter for monitoring transaction lifecycle events. This allows you to track proof verification in real-time.

### Event Types

| Event | Description | When Triggered |
|-------|-------------|----------------|
| `includedInBlock` | Transaction included in a block | Shortly after submission |
| `finalized` | Transaction finalized on-chain | After block finality (~12-18 seconds on Volta) |
| `error` | Transaction failed | If verification fails or network error occurs |

### Listening to Events

Events are returned from both `verify()` and `batchVerify()` methods:

```typescript
import { zkVerifySession, Library, CurveType } from 'zkverifyjs';
import { ZkVerifyEvents } from 'zkverifyjs';

const session = await zkVerifySession.start().Volta().withAccount(seedPhrase);

const { events, transactionResult } = await session
    .verify()
    .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
    .execute({
        proofData: {
            vk: vkey,
            proof: proof,
            publicSignals: publicSignals
        }
    });

// Listen for transaction inclusion
events.on('includedInBlock', (eventData) => {
    console.log('üì¶ Transaction included in block:', eventData);
    console.log('Block Hash:', eventData.blockHash);
    // You can now show "Processing" status to user
});

// Listen for finalization
events.on('finalized', (eventData) => {
    console.log('‚úÖ Transaction finalized!');
    console.log('Block Hash:', eventData.blockHash);
    console.log('Explorer:', `https://testnet-explorer.zkverify.io/vverify/transaction/${eventData.txHash}`);
    // Update leaderboard, send notification, etc.
});

// Handle errors
events.on('error', (error) => {
    console.error('‚ùå Transaction error:', error);
    // Notify user, retry, etc.
});
```

### Awaiting Transaction Results

You can also await the final result as a Promise:

```typescript
// Submit proof and wait for finalization
const { events, transactionResult } = await session.verify()
    .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
    .execute({ proofData: { vk, proof, publicSignals } });

// The transactionResult promise resolves when finalized
try {
    const result = await transactionResult;
    console.log('‚úÖ Verification Complete!');
    console.log('Transaction Hash:', result.txHash);
    console.log('Block Hash:', result.blockHash);
    console.log('Statement:', result.statement);

    // At this point, you can safely update your leaderboard
    updateLeaderboard(result);
} catch (error) {
    console.error('‚ùå Verification failed:', error);
}
```

### Combining Events and Async/Await

You can use both patterns together for comprehensive monitoring:

```typescript
async function submitAndMonitor(proof, publicSignals, vk) {
    const { events, transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute({ proofData: { vk, proof, publicSignals } });

    // Set up event listeners for UI updates
    events.on('includedInBlock', () => {
        updateStatus('Verifying on zkVerify...');
    });

    events.on('finalized', (data) => {
        updateStatus('Verification Complete!');
        showExplorerLink(data.txHash);
    });

    events.on('error', (err) => {
        showError(err.message);
    });

    // Await final result
    const result = await transactionResult;
    return result;
}
```

### Monitoring Multiple Transactions

For high-volume applications, you can track multiple transactions:

```typescript
const activeTransactions = new Map();

async function submitProof(playerId, proof, publicSignals, vk) {
    const { events, transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute({ proofData: { vk, proof, publicSignals } });

    const txHash = await transactionResult.then(r => r.txHash);

    // Track by player ID
    activeTransactions.set(playerId, {
        txHash,
        status: 'pending',
        events,
        transactionResult
    });

    // Set up monitoring
    events.on('finalized', () => {
        const tx = activeTransactions.get(playerId);
        tx.status = 'verified';
        activeTransactions.set(playerId, tx);
        notifyPlayer(playerId, 'Score verified!');
    });

    return txHash;
}
```

## Event Monitoring for Leaderboard Integration

To build a real-time leaderboard that updates automatically when proofs are verified, you need to set up persistent event monitoring on your backend server.

### Subscribing to zkVerify Events

Use the `session.subscribe()` method to listen for specific events:

```typescript
import { zkVerifySession, ZkVerifyEvents } from 'zkverifyjs';
import dotenv from 'dotenv';
dotenv.config();

const seedPhrase = process.env.ZKVERIFY_SEED_PHRASE;

async function setupLeaderboardMonitor() {
    // Start session
    const session = await zkVerifySession.start()
        .Volta()
        .withAccount(seedPhrase);

    // Subscribe to proof verification events
    session.subscribe([
        {
            event: ZkVerifyEvents.ProofVerified,
            callback: async (eventData) => {
                console.log('üéâ New proof verified!', eventData);

                // Extract data from event
                const {
                    statement,
                    submitter,
                    domainId
                } = eventData;

                // Update leaderboard based on verified proof
                await updateLeaderboard(eventData);
            }
        },
        {
            event: ZkVerifyEvents.NewAggregationReceipt,
            callback: (eventData) => {
                console.log('üì¶ New aggregation receipt:', eventData);
                // Handle aggregated proofs
                await handleAggregatedProofs(eventData);
            },
            options: {
                domainId: 1 // Optional: filter by domain
            }
        }
    ]);

    console.log('‚úÖ Event monitoring started');
    return session;
}
```

### Complete Leaderboard Backend Example

Here's a complete example showing how to integrate event monitoring with your leaderboard:

```typescript
import Fastify from 'fastify';
import { zkVerifySession, ZkVerifyEvents, Library, CurveType } from 'zkverifyjs';
import dotenv from 'dotenv';
import pg from 'pg';
dotenv.config();

const { Pool } = pg;
const db = new Pool({ connectionString: process.env.DATABASE_URL });

const fastify = Fastify({ logger: true });
let zkSession: any;

// Database schema (PostgreSQL)
/*
CREATE TABLE leaderboard (
    id SERIAL PRIMARY KEY,
    player_address VARCHAR(42) NOT NULL,
    score INTEGER NOT NULL,
    session_id BIGINT NOT NULL UNIQUE,
    tx_hash VARCHAR(66) NOT NULL UNIQUE,
    verified_at TIMESTAMP DEFAULT NOW()
);
*/

async function startZkMonitor() {
    zkSession = await zkVerifySession.start()
        .Volta()
        .withAccount(process.env.ZKVERIFY_SEED_PHRASE);

    zkSession.subscribe([
        {
            event: ZkVerifyEvents.ProofVerified,
            callback: handleProofVerified
        }
    ]);

    console.log('‚úÖ zkVerify event monitor started');
}

async function handleProofVerified(eventData: any) {
    const { statement, submitter, domainId } = eventData;

    fastify.log.info(`Proof verified: ${statement} by ${submitter}`);

    // In production, you'd fetch the transaction details
    // using the statement hash to get public signals
    const publicSignals = await fetchPublicSignals(statement);

    if (!publicSignals) {
        fastify.log.error('Could not fetch public signals for statement:', statement);
        return;
    }

    const claimedTotal = parseInt(publicSignals[0]);
    const sessionId = publicSignals[1];
    const playerAddress = publicSignals[2];

    // Insert into leaderboard
    try {
        await db.query(
            `INSERT INTO leaderboard (player_address, score, session_id, tx_hash)
             VALUES ($1, $2, $3, $4)
             ON CONFLICT (session_id) DO NOTHING`,
            [playerAddress, claimedTotal, sessionId, statement]
        );
        fastify.log.info(`‚úÖ Score added to leaderboard: ${playerAddress} = ${claimedTotal}`);
    } catch (error) {
        fastify.log.error('Database error:', error);
    }
}

async function fetchPublicSignals(statementHash: string): Promise<any[]> {
    // This would query zkVerify or your storage for public signals
    // For now, return null as a placeholder
    // In production, you'd store public signals when proof is submitted
    return null;
}

// Start everything
async function start() {
    await startZkMonitor();
    await fastify.listen({ port: 3000, host: '0.0.0.0' });
}

start().catch(console.error);
```

### Storing Public Signals for Later Retrieval

Since `ProofVerified` events only provide a `statement` hash, you need to store public signals when proofs are submitted:

```typescript
// Database schema
/*
CREATE TABLE pending_verifications (
    statement_hash VARCHAR(66) PRIMARY KEY,
    claimed_total INTEGER NOT NULL,
    session_id BIGINT NOT NULL,
    player_address VARCHAR(42) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
*/

// When submitting proof (in /verify-score endpoint):
fastify.post('/verify-score', async (request, reply) => {
    const { proof, publicSignals } = request.body;

    const session = await zkVerifySession.start()
        .Volta()
        .withAccount(process.env.ZKVERIFY_SEED_PHRASE);

    const { transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute({ proofData: { vk, proof, publicSignals } });

    const txInfo = await transactionResult;

    // Store public signals with statement hash for later retrieval
    await db.query(
        `INSERT INTO pending_verifications (statement_hash, claimed_total, session_id, player_address)
         VALUES ($1, $2, $3, $4)`,
        [txInfo.statement, publicSignals[0], publicSignals[1], publicSignals[2]]
    );

    return { success: true, txHash: txInfo.txHash };
});

// When ProofVerified event fires:
async function handleProofVerified(eventData: any) {
    const { statement } = eventData;

    // Retrieve stored public signals
    const result = await db.query(
        'SELECT * FROM pending_verifications WHERE statement_hash = $1',
        [statement]
    );

    if (result.rows.length === 0) {
        console.error('No pending verification found for:', statement);
        return;
    }

    const { claimed_total, session_id, player_address } = result.rows[0];

    // Insert into leaderboard
    await db.query(
        `INSERT INTO leaderboard (player_address, score, session_id, tx_hash)
         VALUES ($1, $2, $3, $4)`,
        [player_address, claimed_total, session_id, statement]
    );

    // Clean up pending verification
    await db.query('DELETE FROM pending_verifications WHERE statement_hash = $1', [statement]);
}
```

### Frontend: Real-time Leaderboard Updates

Use WebSockets or polling to show real-time updates to players:

```typescript
// Backend: WebSocket endpoint
fastify.register(require('fastify-websocket'));

fastify.ready(err => {
    if (err) throw err;

    fastify.websocketServer.on('connection', (socket, req) => {
        socket.send(JSON.stringify({ type: 'connected' }));

        // Broadcast leaderboard updates
        zkSession.subscribe([
            {
                event: ZkVerifyEvents.ProofVerified,
                callback: async (eventData) => {
                    const leaderboard = await fetchLeaderboard();
                    socket.send(JSON.stringify({
                        type: 'leaderboard_update',
                        data: leaderboard
                    }));
                }
            }
        ]);
    });
});

// Frontend: Connect to WebSocket
const ws = new WebSocket('ws://localhost:3000/ws');

ws.onmessage = (event) => {
    const message = JSON.parse(event.data);

    if (message.type === 'leaderboard_update') {
        renderLeaderboard(message.data);
    }
};
```

### Handling Failed Verifications

You should also subscribe to error events:

```typescript
zkSession.subscribe([
        {
            event: ZkVerifyEvents.ProofVerified,
            callback: handleProofVerified
        },
        {
            event: 'ErrorEvent', // Generic error event
            callback: (error: any) => {
                console.error('zkVerify error:', error);
                // Notify admin or log to monitoring service
            }
        }
]);
```

### Production Considerations

1. **Persistence:**
   - Store event data for audit trails
   - Use a message queue (RabbitMQ, Redis) for reliability

2. **Idempotency:**
   - Handle duplicate events gracefully
   - Use unique constraints in your database

3. **Scaling:**
   - Run multiple instances with load balancing
   - Each instance can subscribe to all events
   - Use database constraints to prevent duplicates

4. **Monitoring:**
   - Track event processing latency
   - Set up alerts for missed events
   - Monitor database connection health

5. **Backup:**
   - Consider a polling fallback if WebSocket drops
   - Periodically query blockchain for missed verifications

## Usage Examples

### Example 1: cURL Command
```bash
curl -X POST http://localhost:3000/verify-score \
  -H "Content-Type: application/json" \
  -d '{
    "proof": {
      "pi_a": ["0x123...", "0x456"],
      "pi_b": [["0x789", "0xabc"], ["0xdef", "0x012"]],
      "pi_c": ["0x345", "0x678"],
      "protocol": "groth16",
      "curve": "bn128"
    },
    "publicSignals": ["150", "987654321", "0x1234567890abcdef1234567890abcdef12345678", "0xabcdef...", "1"]
  }'
```

### Example 2: JavaScript Fetch (Browser)
```javascript
const response = await fetch('http://localhost:3000/verify-score', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    proof: proofObject,      // From snarkjs.groth16.fullProve()
    publicSignals: publicArray
  })
});

const data = await response.json();
if (data.success) {
  console.log('Transaction Hash:', data.transactionHash);
  console.log('Explorer URL:', data.explorerUrl);
} else {
  console.error('Error:', data.error);
}
```

### Example 3: JavaScript Fetch (Node.js)
```javascript
import fetch from 'node-fetch';

const proofData = {
  proof: require('./proof.json'),
  publicSignals: require('./public.json')
};

const response = await fetch('http://localhost:3000/verify-score', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(proofData)
});

const data = await response.json();
console.log(data);
```

## Complete Workflows

### Workflow A: CLI (Command Line)
Use this for testing and development without the server.

1. Generate proof locally:
   ```bash
   snarkjs groth16 fullprove input.json circuits/score_prover_js/score_prover.wasm circuits/score_prover_final.zkey proof.json public.json
   ```

2. Submit to zkVerify:
   ```bash
   node scripts/verify_score.js
   ```

3. Monitor transaction on explorer using the returned transaction hash.

### Workflow B: Browser + Server (Production)
Use this for a real game application.

1. **Start the Backend Server**:
   ```bash
   npm run dev
   ```

2. **Open Browser Test Interface**:
   ```bash
   python3 -m http.server 8000
   # Then open http://localhost:8000/test.html
   ```

3. **Generate Proof in Browser**:
   - Enter your 5 level scores
   - Enter your secret (private)
   - Enter your player address (public)
   - Session ID is auto-generated
   - Click "Step 1: Generate ZK Proof"

4. **Submit to zkVerify**:
   - Click "Step 2: Submit to zkVerify"
   - The browser sends proof to backend server
   - Backend relays to zkVerify network
   - Receive transaction hash and explorer link

5. **Monitor on Leaderboard**:
   - Your app listens for zkVerify attestation events
   - Verify sessionId is unique
   - Update leaderboard with verified score

### Workflow C: Custom Integration
For your own game frontend:

```javascript
// 1. Player finishes game
const scores = [100, 200, 150, 300, 250];
const totalScore = scores.reduce((a, b) => a + b, 0);
const sessionId = Date.now().toString() + Math.floor(Math.random() * 1000);
const playerAddress = await getPlayerWalletAddress();
const secret = await getPlayerSecret();

// 2. Generate ZK proof
const input = {
  scores,
  secret: toBigInt(secret),
  claimedTotal: totalScore,
  sessionId: toBigInt(sessionId),
  playerAddress: toBigInt(playerAddress)
};

const { proof, publicSignals } = await snarkjs.groth16.fullProve(
  input,
  'circuits/score_prover_js/score_prover.wasm',
  'circuits/score_prover_final.zkey'
);

// 3. Submit to backend
const response = await fetch('http://localhost:3000/verify-score', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ proof, publicSignals })
});

const { transactionHash, explorerUrl } = await response.json();

// 4. Store pending score with transaction hash
await savePendingScore(playerAddress, totalScore, transactionHash, sessionId);

// 5. Backend monitors zkVerify for finalization
// When finalized, verify sessionId uniqueness and update leaderboard
```

## Running the Server

### Development Mode
```bash
npm run dev
```
Server runs on port 3000 (configurable via `PORT` environment variable).

### Production Build
```bash
npm run build
```
Compiles TypeScript to JavaScript in `dist/` directory.

## Verification Key Registration

By default, this project includes the full verification key with each proof submission. For production applications with high volume, you can **register your verification key on-chain** to reduce transaction costs and improve performance.

### When to Register Your VK

- **Development/Testing**: Not necessary - submit VK inline
- **Low-volume apps**: Optional - inline submission works fine
- **High-volume games**: Recommended - register once, submit many proofs with hash reference

### Registering the Verification Key

Use `registerVerificationKey()` method to upload your VK to zkVerify:

```typescript
import { zkVerifySession, Library, CurveType } from 'zkverifyjs';
import dotenv from 'dotenv';
import fs from 'fs';
dotenv.config();

const seedPhrase = process.env.ZKVERIFY_SEED_PHRASE;

// Start session
const session = await zkVerifySession.start()
    .Volta()
    .withAccount(seedPhrase);

// Load your verification key
const vkey = JSON.parse(fs.readFileSync('verification_key.json', 'utf8'));

// Register the verification key
const { events, transactionResult } = await session
    .registerVerificationKey()
    .groth16({
        library: Library.snarkjs,
        curve: CurveType.bn128
    })
    .execute(vkey);

// Wait for registration to complete
const vkTransactionInfo = await transactionResult;
console.log('‚úÖ Verification Key Registered!');
console.log('Statement Hash:', vkTransactionInfo.statementHash);
console.log('View on Explorer:', `https://testnet-explorer.zkverify.io/vverify/transaction/${vkTransactionInfo.txHash}`);
```

### Submitting Proofs with Registered VK

Once registered, use `.withRegisteredVk()` and provide the `statementHash` instead of the full VK:

```typescript
// After registration, use the statement hash for all future proofs
const { events, transactionResult } = await session
    .verify()
    .groth16({
        library: Library.snarkjs,
        curve: CurveType.bn128
    })
    .withRegisteredVk() // Important: indicates VK is already registered
    .execute({
        proofData: {
            vk: vkTransactionInfo.statementHash, // Use hash, not full VK
            proof: proof,
            publicSignals: publicSignals
        },
        domainId: 0 // Optional domain ID for aggregation
    });
```

### Benefits of VK Registration

| Benefit | Inline VK | Registered VK |
|---------|-----------|---------------|
| Transaction Size | Large (includes full VK) | Small (only hash reference) |
| Transaction Cost | Higher | Lower |
| Setup Complexity | None | One-time registration |
| Use Case | Development, low volume | Production, high volume |

### Updating Your Server for Registered VKs

Modify `server.ts` to support registered VKs:

```typescript
// In your server.ts, load the statement hash from environment or config
const REGISTERED_VK_HASH = process.env.REGISTERED_VK_HASH; // e.g., "0xabc123..."

fastify.post('/verify-score', async (request, reply) => {
    const { proof, publicSignals } = request.body;

    const session = await zkVerifySession.start().Volta().withAccount(seedPhrase);

    const { transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .withRegisteredVk() // Use registered VK
        .execute({
            proofData: {
                vk: REGISTERED_VK_HASH, // Hash instead of full VK
                proof: proof,
                publicSignals: publicSignals
            }
        });

    // ... rest of your logic
});
```

### Complete Example: Register and Use VK

```typescript
import { zkVerifySession, Library, CurveType } from 'zkverifyjs';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
dotenv.config();

async function setupRegisteredVK() {
    const seedPhrase = process.env.ZKVERIFY_SEED_PHRASE;

    // Start session
    const session = await zkVerifySession.start()
        .Volta()
        .withAccount(seedPhrase);

    // Load verification key
    const vkeyPath = path.join(__dirname, 'verification_key.json');
    const vkey = JSON.parse(fs.readFileSync(vkeyPath, 'utf8'));

    // Register VK
    console.log('üìù Registering verification key...');
    const { events, transactionResult } = await session
        .registerVerificationKey()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute(vkey);

    // Listen for events
    events.on('includedInBlock', (data) => {
        console.log('üì¶ VK registration included in block:', data.blockHash);
    });

    events.on('finalized', (data) => {
        console.log('‚úÖ VK registration finalized!');
        console.log('üìã Statement Hash:', data.statementHash);
        console.log('üîó Explorer:', `https://testnet-explorer.zkverify.io/vverify/transaction/${data.txHash}`);
    });

    events.on('error', (error) => {
        console.error('‚ùå Registration failed:', error);
    });

    // Wait for completion
    const result = await transactionResult;

    console.log('üéâ VK registered successfully!');
    console.log('Statement hash:', result.statementHash);
    console.log('Transaction hash:', result.txHash);

    // Save the statement hash for future use
    console.log('üíæ Save this statement hash in your .env:');
    console.log(`REGISTERED_VK_HASH="${result.statementHash}"`);

    return result.statementHash;
}

// Run setup
setupRegisteredVK().catch(console.error);
```

### Managing Multiple Verification Keys

If your game uses different circuits for different modes:

```typescript
const VK_HASHES = {
    easyMode: process.env.VK_EASY,
    hardMode: process.env.VK_HARD,
    tournament: process.env.VK_TOURNAMENT
};

async function submitProofWithVK(proof, publicSignals, mode) {
    const vkHash = VK_HASHES[mode];

    const { transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .withRegisteredVk()
        .execute({
            proofData: {
                vk: vkHash,
                proof: proof,
                publicSignals: publicSignals
            }
        });

    return await transactionResult;
}
```

## Troubleshooting

### Common Issues

**"Invalid proof" or "Proof generation failed"**
- Check that all scores are < 1001
- Verify that `claimedTotal` equals the sum of scores
- Ensure all inputs are in correct format (bigints, hex strings, or numbers)

**"ZKVERIFY_SEED_PHRASE not found in environment"**
- Create a `.env` file in the root directory
- Copy your seed phrase from `.env.example` and replace with your actual seed phrase
- Ensure `.env` is in the project root (not in a subdirectory)

**"Transaction failed" or "Insufficient balance"**
- Check that your wallet has VFY testnet tokens
- Visit the [zkVerify faucet](https://faucet.zkverify.io/) to get testnet tokens
- Verify your wallet address is correct

**CORS errors (in production)**
- Update the CORS origin in `server.ts` line 14:
  ```typescript
  fastify.register(cors, {
      origin: 'https://your-game-domain.com', // Restrict to your domain
  });
  ```

**"Module not found" errors**
- Run `npm install` to install dependencies
- Ensure you're in the project root directory

**Circuit compilation errors**
- Ensure Circom compiler is installed correctly
- Check that `circomlib` is installed: `npm install circomlib`
- Verify circuit syntax matches pragma version `2.1.0`

## Security Best Practices

1. **Never hardcode seed phrases**
   - Always use environment variables (`ZKVERIFY_SEED_PHRASE`)
   - Add `.env` to `.gitignore`
   - Never commit `.env` files to version control

2. **Use unique session IDs**
   - Generate unique session IDs per game session
   - Recommended format: timestamp + random number or UUID
   - Never reuse session IDs across different game sessions

3. **Store secrets securely on client**
   - Use `localStorage` or `sessionStorage` (not in plain text in code)
   - Consider encrypting the secret
   - Allow users to set and rotate their secret

4. **Verify attestations before updating leaderboard**
   - Always verify that sessionId hasn't been used before
   - Check that playerAddress matches the expected wallet
   - Only update leaderboard after zkVerify attestation is finalized

5. **Validate all inputs**
   - Validate score ranges on the backend (defensive programming)
   - Reject scores > 1000 per level
   - Verify wallet address format

6. **CORS configuration**
   - In production, restrict CORS to your game's domain only
   - Don't use `origin: '*'` in production environments

7. **Monitor zkVerify transactions**
   - Listen for `Attestation` events from zkVerify
   - Handle both `finalized` and `error` events
   - Implement retry logic for failed transactions

8. **Rate limiting**
   - Implement rate limiting on the backend to prevent abuse
   - Limit the number of proofs a player can submit per time period

## Replay Protection in Detail

### How Session ID Uniqueness Works

The `sessionId` is included in the proof's public signals, but **the circuit itself does not enforce uniqueness**. The **prevention of replay attacks happens in your backend/leaderboard logic**.

### Division of Responsibilities

| Component | Responsibility |
|-----------|----------------|
| **zkVerify Network** | Cryptographically verifies the proof is mathematically correct (sums match, secret known) |
| **Your Backend** | Prevents the same proof from being used twice by tracking sessionIds |

Without the backend's uniqueness check, a malicious player could reuse a valid proof multiple times to inflate their score.

### Normal Flow (Unique Session ID)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     1. Generate unique      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Player   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ   Browser   ‚îÇ
‚îÇ             ‚îÇ       sessionId: "17365...  ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                 ‚îÇ
                                                 ‚îÇ 2. Generate proof
                                                 ‚ñº
                                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                           ‚îÇ  SnarkJS    ‚îÇ
                                           ‚îÇ  (Client)   ‚îÇ
                                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                  ‚îÇ
                                                  ‚îÇ 3. Submit proof
                                                  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     4. Check: sessionId used?    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  zkVerify   ‚îÇ ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÇ  Backend    ‚îÇ
‚îÇ   Network   ‚îÇ                                    ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     5. NO ‚Üí Submit to zkVerify   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                 ‚îÇ       ‚îÇ
                                                 ‚îÇ       ‚îÇ 6. Get attestation
                                                 ‚ñº       ‚îÇ
                                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
                                           ‚îÇ  Leaderboard‚îÇ‚óÄ‚îò
                                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Replay Attack Scenario

**What a malicious player attempts:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     1. Generate proof      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Malicious  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ   Browser   ‚îÇ
‚îÇ    Player   ‚îÇ     sessionId: "17365...    ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                 ‚îÇ
                                                 ‚îÇ 2. Submit proof
                                                 ‚ñº
                                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                           ‚îÇ  Backend    ‚îÇ
                                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                  ‚îÇ
                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                              ‚îÇ 3. Check: sessionId used?               ‚îÇ
                              ‚îÇ   Database query: SELECT * FROM scores  ‚îÇ
                              ‚îÇ   WHERE session_id = "17365..."          ‚îÇ
                              ‚îÇ   Result: NO rows found                  ‚îÇ
                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                    ‚îÇ
                                                    ‚îÇ 4. NO ‚Üí Submit to zkVerify
                                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     5. Verify success     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  zkVerify   ‚îÇ ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÇ  Backend    ‚îÇ
‚îÇ   Network   ‚îÇ                            ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                 ‚îÇ
                                                 ‚îÇ 6. Store score + sessionId
                                                 ‚ñº
                                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                           ‚îÇ  Leaderboard‚îÇ
                                           ‚îÇ  Score: 1000 ‚îÇ
                                           ‚îÇ  sessionId:  ‚îÇ
                                           ‚îÇ  17365...   ‚îÇ
                                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                  ‚îÇ
                                                  ‚îÇ 7. ‚ö†Ô∏è REUSE SAME PROOF ‚ö†Ô∏è
                                                  ‚îÇ    sessionId: "17365..."
                                                  ‚ñº
                                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                           ‚îÇ  Backend    ‚îÇ
                                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                  ‚îÇ
                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                              ‚îÇ 8. Check: sessionId used?               ‚îÇ
                              ‚îÇ   Database query: SELECT * FROM scores  ‚îÇ
                              ‚îÇ   WHERE session_id = "17365..."          ‚îÇ
                              ‚îÇ   Result: 1 row FOUND!                  ‚îÇ
                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                    ‚îÇ
                                                    ‚îÇ 9. YES ‚Üí REJECT
                                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚ùå REPLAY ATTACK BLOCKED                                           ‚îÇ
‚îÇ  Error: "Session ID already used - replay attack prevented"        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Backend SessionId Validation Code

**Important:** This validation must happen **before** submitting to zkVerify, or at minimum **before** updating the leaderboard.

#### Example: PostgreSQL Implementation

```javascript
import pg from 'pg';
const { Pool } = pg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

async function submitScore(playerAddress, score, sessionId, transactionHash) {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // 1. Check if sessionId has been used before
    const existingResult = await client.query(
      'SELECT id FROM scores WHERE session_id = $1 FOR UPDATE',
      [sessionId]
    );

    if (existingResult.rows.length > 0) {
      await client.query('ROLLBACK');
      throw new Error('Session ID already used - replay attack prevented');
    }

    // 2. Verify zkVerify attestation is valid
    const isValid = await verifyAttestation(transactionHash);
    if (!isValid) {
      await client.query('ROLLBACK');
      throw new Error('Invalid zkVerify attestation');
    }

    // 3. Check that playerAddress matches attestation
    const attestation = await getAttestationDetails(transactionHash);
    if (attestation.playerAddress !== playerAddress) {
      await client.query('ROLLBACK');
      throw new Error('Player address mismatch');
    }

    // 4. Store the score (with unique constraint on session_id)
    await client.query(
      `INSERT INTO scores 
       (player_address, score, session_id, tx_hash, created_at)
       VALUES ($1, $2, $3, $4, NOW())`,
      [playerAddress, score, sessionId, transactionHash]
    );

    await client.query('COMMIT');
    return { success: true, message: 'Score added to leaderboard' };

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Create table with unique constraint
/*
CREATE TABLE scores (
  id SERIAL PRIMARY KEY,
  player_address VARCHAR(42) NOT NULL,
  score INTEGER NOT NULL,
  session_id BIGINT NOT NULL UNIQUE,
  tx_hash VARCHAR(66) NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT NOW()
);
*/
```

#### Example: Redis/Memory Implementation (for testing)

```javascript
const usedSessionIds = new Set();

function isSessionIdUsed(sessionId) {
  return usedSessionIds.has(sessionId);
}

function markSessionIdUsed(sessionId) {
  usedSessionIds.add(sessionId);
}

async function submitScore(playerAddress, score, sessionId, transactionHash) {
  // 1. Check if sessionId has been used before
  if (isSessionIdUsed(sessionId)) {
    throw new Error('Session ID already used - replay attack prevented');
  }

  // 2. Verify zkVerify attestation
  const isValid = await verifyAttestation(transactionHash);
  if (!isValid) {
    throw new Error('Invalid zkVerify attestation');
  }

  // 3. Store the score
  await saveScoreToLeaderboard(playerAddress, score, sessionId, transactionHash);

  // 4. Mark sessionId as used
  markSessionIdUsed(sessionId);

  return { success: true, message: 'Score added to leaderboard' };
}
```

### What If You Don't Track SessionIds?

If you don't implement the uniqueness check in your backend:

```
‚úÖ Proof submitted ‚Üí zkVerify verifies ‚Üí Score added: 1000
‚úÖ Same proof submitted again ‚Üí zkVerify verifies ‚Üí Score added: 1000 (duplicate!)
‚úÖ Same proof submitted again ‚Üí zkVerify verifies ‚Üí Score added: 1000 (triple!)
...
‚úÖ Attacker submits 1000 times ‚Üí Score inflated: 1,000,000
```

This would be a **critical vulnerability** allowing infinite score inflation.

### Important Clarifications

**Session IDs do NOT prevent legitimate duplicate scores:**
- A player can legitimately score 1000 multiple times
- Each submission must have a **different sessionId**
- Example: Playing the game 5 times = 5 different sessionIds = 5 valid score entries

**The circuit does NOT enforce uniqueness:**
- The circuit only validates: scores sum to total, scores < 1001, secret known
- Uniqueness checking is **purely a backend responsibility**
- This is intentional - it keeps the circuit simple and efficient

**Why this design?**
- Circuits are expensive to compute - keep them minimal
- Backend database operations are fast - let them handle uniqueness
- zkVerify provides cryptographic proof of correctness
- Your backend provides guarantee of non-replay

### Integration with Server Endpoint

Update your `server.ts` to include sessionId validation:

```typescript
// After receiving transactionHash from zkVerify
async function handleZkVerifyFinalization(transactionHash, publicSignals) {
  const sessionId = publicSignals[1]; // sessionId is at index 1
  const playerAddress = publicSignals[2]; // playerAddress is at index 2

  // Check uniqueness before updating leaderboard
  if (await isSessionIdUsed(sessionId)) {
    console.error(`Duplicate sessionId detected: ${sessionId}`);
    return;
  }

  // Update leaderboard
  await addToLeaderboard({
    playerAddress,
    score: parseInt(publicSignals[0]), // claimedTotal at index 0
    sessionId,
    transactionHash
  });
}
```

## How it Works

The circuit ensures that the five hidden `scores` sum up exactly to the public `claimedTotal`. Any attempt to spoof the total without matching individual level scores will fail the ZK constraint. Once verified by zkVerify, you get a cryptographic attestation that the score is valid.

The security model works as follows:
1. **Player proves they know the secret** for their address (identity binding)
2. **Player proves the scores are valid** (sums to claimed total, each < 1001)
3. **Unique session ID prevents replay** (same proof can't be submitted twice)
4. **zkVerify network cryptographically verifies** the proof
5. **Attestation event confirms validity** (score can be added to leaderboard)
6. **Backend validates sessionId uniqueness** (ensures no duplicate submissions)

## Resources

- [zkVerify Documentation](https://docs.zkverify.io/)
- [zkVerify Testnet Explorer](https://testnet-explorer.zkverify.io/)
- [Circom Documentation](https://docs.circom.io/)
- [SnarkJS Documentation](https://github.com/iden3/snarkjs)
- [zkVerify Faucet](https://faucet.zkverify.io/)
