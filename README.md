# ZK Score Verification with zkVerify

This project demonstrates how to use Zero-Knowledge Proofs to verify gaming scores and submit them to the [zkVerify](https://zkverify.io/) network.

## Project Structure
- `circuits/`: Contains the `score_prover.circom` circuit and compiled artifacts
- `scripts/`: Integration scripts for zkVerify CLI workflow
- `server.ts`: Production backend server for proof submission
- `test.html`: Browser-based proof generation UI
- `unity/`: Unity WebGL integration files
  - `Scripts/ZKProverBridge.cs`: C# wrapper for ZK proof generation
  - `Plugins/WebGL/ZKProver.jslib`: JavaScript bridge to snarkjs
  - `UNITY_SETUP.md`: Detailed Unity integration guide

## Prerequisites
1. **Circom Compiler**: Install from [circom.io](https://docs.circom.io/getting-started/installation/).
2. **SnarkJS**: Installed via `npm install`.
3. **zkVerify Account**: You need a Substrate-compatible wallet (like Polkadot.js) and some testnet VFY tokens.

## Security Architecture

This project implements a three-layer security model to ensure score authenticity and prevent fraud:

### 1. Replay Protection (sessionId)
- **Purpose**: Prevents proof replay attacks
- **How it works**: Each game session generates a unique sessionId that's included in the proof
- **Requirements**: Must be unique per session and never reused
- **Example**: `Date.now().toString() + Math.floor(Math.random() * 1000).toString()` or UUID

Without sessionId, an attacker could reuse a valid proof multiple times to inflate their score on a leaderboard.

### 2. Identity Binding (playerAddress)
- **Purpose**: Binds the proof to a specific player's wallet address
- **Format**: Hex address starting with `0x...`
- **Example**: `0x1234567890abcdef1234567890abcdef12345678`

Without playerAddress, any player could submit another player's valid proof as their own.

### 3. Secret Commitment (secret)
- **Purpose**: Proves the player knows a private secret for their address
- **Format**: Text, number, or hex value (never revealed publicly)
- **How it works**: The circuit computes `Poseidon(secret, playerAddress)` and includes it in public signals
- **Example**: `my-secret-key-12345` or `0x1a2b3c4d5e6f...`

The secret proves that the proof was generated by the legitimate owner of that wallet address. Without this, anyone could generate proofs for any address.

## Circuit Constraints

The `score_prover.circom` circuit enforces the following constraints:

1. **Score Bounds**: Each individual score must be < 1001
   - Prevents unrealistic or manipulated score values
   - Example: If a player inputs score=9999, proof generation fails

2. **Sum Consistency**: `scores[0] + scores[1] + scores[2] + scores[3] + scores[4] === claimedTotal`
   - Ensures the claimed total actually matches the individual scores
   - Example: `[100, 200, 150, 300, 250]` must have `claimedTotal = 1000`

3. **Identity Commitment**: `Poseidon(secret, playerAddress) === secretCommitment`
   - Proves the prover knows the secret for this specific address
   - Output `secretCommitment` is the hash result

### Quick Reference: Circuit Inputs/Outputs

| Name | Type | Public/Private | Description | Example |
|------|------|----------------|-------------|---------|
| **Inputs** | | | | |
| `scores[5]` | number[] | Private | Individual level scores (0-1000) | `[100, 200, 150, 300, 250]` |
| `secret` | bigint | Private | Player's secret key (never revealed) | `123456789` or `"my-secret"` |
| `claimedTotal` | bigint | Public | Sum of all scores | `1000` |
| `sessionId` | bigint | Public | Unique session identifier | `1736543210123` |
| `playerAddress` | bigint | Public | Player's wallet address | `0x1234...5678` |
| **Outputs** | | | | |
| `secretCommitment` | bigint | Public | Hash(secret, playerAddress) | `0xabc...def` |
| `isValid` | bigint | Public | Always equals 1 | `1` |

## Public vs Private Inputs

The `score_prover.circom` circuit distinguishes between inputs that remain hidden and those that are publicly visible:

| Name | Type | Privacy | Description |
|------|------|----------|-------------|
| **Private Inputs** | | | |
| `scores[5]` | number[] | âŒ Private | Individual level scores - never revealed to anyone |
| `secret` | bigint | âŒ Private | Player's secret key - proves identity without disclosure |
| **Public Inputs** | | | |
| `claimedTotal` | bigint | âœ… Public | Sum of scores - visible on leaderboard |
| `sessionId` | bigint | âœ… Public | Unique session identifier - prevents replay attacks |
| `playerAddress` | bigint | âœ… Public | Player's wallet address - binds proof to owner |
| **Public Outputs** | | | |
| `secretCommitment` | bigint | âœ… Public | Hash(secret, playerAddress) - verifies secret knowledge |
| `isValid` | bigint | âœ… Public | Always equals 1 - indicates proof validity |

### Why This Separation Matters

**Private inputs enable true zero-knowledge:**
- Scores can be proven valid without revealing individual level performance
- Secret can prove identity without exposing actual secret value

**Public inputs enable verification:**
- Leaderboard needs `claimedTotal` to display scores
- Backend needs `sessionId` to prevent replay attacks
- `playerAddress` ensures the proof belongs to the right player
- `secretCommitment` allows anyone to verify the secret is correct without knowing it

## Circuit Code Walkthrough

Let's examine how the `score_prover.circom` circuit enforces game rules and security constraints.

### Circuit Structure

```circom
pragma circom 2.1.0;

include "../node_modules/circomlib/circuits/poseidon.circom";
include "../node_modules/circomlib/circuits/comparators.circom";

template ScoreVerifier(n) {
    // ... signals and logic
}
```

## Monitoring zkVerify Transactions

The zkVerify library provides an EventEmitter for monitoring transaction lifecycle events. This allows you to track proof verification in real-time.

### Event Types

| Event | Description | When Triggered |
|-------|-------------|----------------|
| `includedInBlock` | Transaction included in a block | Shortly after submission |
| `finalized` | Transaction finalized on-chain | After block finality (~12-18 seconds on Volta) |
| `error` | Transaction failed | If verification fails or network error occurs |

### Listening to Events

Events are returned from both `verify()` and `batchVerify()` methods:

```typescript
import { zkVerifySession, Library, CurveType } from 'zkverifyjs';
import { ZkVerifyEvents } from 'zkverifyjs';
import { getNetworkConfig, getSeedPhrase, Network } from './src/zkNetworkConfig';

const networkConfig = getNetworkConfig();
const network: Network = (process.env.ZKVERIFY_NETWORK as Network) || 'testnet';
const seedPhrase = getSeedPhrase(network);

const session = await zkVerifySession.start()
    .Custom({
                websocket: networkConfig.websocket,
                rpc: networkConfig.rpc,
                network: network === 'mainnet' ? 'zkVerify' : 'Volta'
            })
    .withAccount(seedPhrase);

const { events, transactionResult } = await session
    .verify()
    .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
    .execute({
        proofData: {
            vk: vkey,
            proof: proof,
            publicSignals: publicSignals
        }
    });

// Listen for transaction inclusion
events.on('includedInBlock', (eventData) => {
    console.log('ğŸ“¦ Transaction included in block:', eventData);
    console.log('Block Hash:', eventData.blockHash);
    // You can now show "Processing" status to user
});

// Listen for finalization
events.on('finalized', (eventData) => {
    console.log('âœ… Transaction finalized!');
    console.log('Block Hash:', eventData.blockHash);
    console.log('Explorer:', `${networkConfig.explorer}/vverify/transaction/${eventData.txHash}`);
    // Update leaderboard, send notification, etc.
});

// Handle errors
events.on('error', (error) => {
    console.error('âŒ Transaction error:', error);
    // Notify user, retry, etc.
});
```

### Awaiting Transaction Results

You can also await the final result as a Promise:

```typescript
// Submit proof and wait for finalization
const { events, transactionResult } = await session.verify()
    .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
    .execute({ proofData: { vk, proof, publicSignals } });

// The transactionResult promise resolves when finalized
try {
    const result = await transactionResult;
    console.log('âœ… Verification Complete!');
    console.log('Transaction Hash:', result.txHash);
    console.log('Block Hash:', result.blockHash);
    console.log('Statement:', result.statement);

    // At this point, you can safely update your leaderboard
    updateLeaderboard(result);
} catch (error) {
    console.error('âŒ Verification failed:', error);
}
```

### Combining Events and Async/Await

You can use both patterns together for comprehensive monitoring:

```typescript
async function submitAndMonitor(proof, publicSignals, vk) {
    const { events, transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute({ proofData: { vk, proof, publicSignals } });

    // Set up event listeners for UI updates
    events.on('includedInBlock', () => {
        updateStatus('Verifying on zkVerify...');
    });

    events.on('finalized', (data) => {
        updateStatus('Verification Complete!');
        showExplorerLink(data.txHash);
    });

    events.on('error', (err) => {
        showError(err.message);
    });

    // Await final result
    const result = await transactionResult;
    return result;
}
```

### Monitoring Multiple Transactions

For high-volume applications, you can track multiple transactions:

```typescript
const activeTransactions = new Map();

async function submitProof(playerId, proof, publicSignals, vk) {
    const { events, transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute({ proofData: { vk, proof, publicSignals } });

    const txHash = await transactionResult.then(r => r.txHash);

    // Track by player ID
    activeTransactions.set(playerId, {
        txHash,
        status: 'pending',
        events,
        transactionResult
    });

    // Set up monitoring
    events.on('finalized', () => {
        const tx = activeTransactions.get(playerId);
        tx.status = 'verified';
        activeTransactions.set(playerId, tx);
        notifyPlayer(playerId, 'Score verified!');
    });

    return txHash;
}
```

## Event Monitoring for Leaderboard Integration

To build a real-time leaderboard that updates automatically when proofs are verified, you need to set up persistent event monitoring on your backend server.

### Subscribing to zkVerify Events

Use the `session.subscribe()` method to listen for specific events:

```typescript
import { zkVerifySession, ZkVerifyEvents } from 'zkverifyjs';
import dotenv from 'dotenv';
import { getNetworkConfig, getSeedPhrase, Network } from './src/zkNetworkConfig';
dotenv.config();

async function setupLeaderboardMonitor() {
    // Start session
    const networkConfig = getNetworkConfig();
    const network: Network = (process.env.ZKVERIFY_NETWORK as Network) || 'testnet';
    const seedPhrase = getSeedPhrase(network);

    const session = await zkVerifySession.start()
        .Custom({
                websocket: networkConfig.websocket,
                rpc: networkConfig.rpc,
                network: network === 'mainnet' ? 'zkVerify' : 'Volta'
            })
        .withAccount(seedPhrase);

    // Subscribe to proof verification events
    session.subscribe([
        {
            event: ZkVerifyEvents.ProofVerified,
            callback: async (eventData) => {
                console.log('ğŸ‰ New proof verified!', eventData);

                // Extract data from event
                const {
                    statement,
                    submitter,
                    domainId
                } = eventData;

                // Update leaderboard based on verified proof
                await updateLeaderboard(eventData);
            }
        },
        {
            event: ZkVerifyEvents.NewAggregationReceipt,
            callback: (eventData) => {
                console.log('ğŸ“¦ New aggregation receipt:', eventData);
                // Handle aggregated proofs
                await handleAggregatedProofs(eventData);
            },
            options: {
                domainId: 1 // Optional: filter by domain
            }
        }
    ]);

    console.log('âœ… Event monitoring started');
    return session;
}
```

### Complete Leaderboard Backend Example

Here's a complete example showing how to integrate event monitoring with your leaderboard:

```typescript
import Fastify from 'fastify';
import { zkVerifySession, ZkVerifyEvents, Library, CurveType } from 'zkverifyjs';
import dotenv from 'dotenv';
import pg from 'pg';
dotenv.config();

const { Pool } = pg;
const db = new Pool({ connectionString: process.env.DATABASE_URL });

const fastify = Fastify({ logger: true });
let zkSession: any;

// Database schema (PostgreSQL)
/*
CREATE TABLE leaderboard (
    id SERIAL PRIMARY KEY,
    player_address VARCHAR(42) NOT NULL,
    score INTEGER NOT NULL,
    session_id BIGINT NOT NULL UNIQUE,
    tx_hash VARCHAR(66) NOT NULL UNIQUE,
    verified_at TIMESTAMP DEFAULT NOW()
);
*/

async function startZkMonitor() {
    const networkConfig = getNetworkConfig();
    const network: Network = (process.env.ZKVERIFY_NETWORK as Network) || 'testnet';
    const seedPhrase = getSeedPhrase(network);

    zkSession = await zkVerifySession.start()
        .Custom({
                websocket: networkConfig.websocket,
                rpc: networkConfig.rpc,
                network: network === 'mainnet' ? 'zkVerify' : 'Volta'
            })
        .withAccount(seedPhrase);

    zkSession.subscribe([
        {
            event: ZkVerifyEvents.ProofVerified,
            callback: handleProofVerified
        }
    ]);

    console.log('âœ… zkVerify event monitor started');
}

async function handleProofVerified(eventData: any) {
    const { statement, submitter, domainId } = eventData;

    fastify.log.info(`Proof verified: ${statement} by ${submitter}`);

    // In production, you'd fetch the transaction details
    // using the statement hash to get public signals
    const publicSignals = await fetchPublicSignals(statement);

    if (!publicSignals) {
        fastify.log.error('Could not fetch public signals for statement:', statement);
        return;
    }

    const claimedTotal = parseInt(publicSignals[0]);
    const sessionId = publicSignals[1];
    const playerAddress = publicSignals[2];

    // Insert into leaderboard
    try {
        await db.query(
            `INSERT INTO leaderboard (player_address, score, session_id, tx_hash)
             VALUES ($1, $2, $3, $4)
             ON CONFLICT (session_id) DO NOTHING`,
            [playerAddress, claimedTotal, sessionId, statement]
        );
        fastify.log.info(`âœ… Score added to leaderboard: ${playerAddress} = ${claimedTotal}`);
    } catch (error) {
        fastify.log.error('Database error:', error);
    }
}

async function fetchPublicSignals(statementHash: string): Promise<any[]> {
    // This would query zkVerify or your storage for public signals
    // For now, return null as a placeholder
    // In production, you'd store public signals when proof is submitted
    return null;
}

// Start everything
async function start() {
    await startZkMonitor();
    await fastify.listen({ port: 3000, host: '0.0.0.0' });
}

start().catch(console.error);
```

### Storing Public Signals for Later Retrieval

Since `ProofVerified` events only provide a `statement` hash, you need to store public signals when proofs are submitted:

```typescript
// Database schema
/*
CREATE TABLE pending_verifications (
    statement_hash VARCHAR(66) PRIMARY KEY,
    claimed_total INTEGER NOT NULL,
    session_id BIGINT NOT NULL,
    player_address VARCHAR(42) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
*/

// When submitting proof (in /verify-score endpoint):
fastify.post('/verify-score', async (request, reply) => {
    const { proof, publicSignals } = request.body;

    const networkConfig = getNetworkConfig();
    const network: Network = (process.env.ZKVERIFY_NETWORK as Network) || 'testnet';
    const seedPhrase = getSeedPhrase(network);

    const session = await zkVerifySession.start()
        .Custom({
                websocket: networkConfig.websocket,
                rpc: networkConfig.rpc,
                network: network === 'mainnet' ? 'zkVerify' : 'Volta'
            })
        .withAccount(seedPhrase);

    const { transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute({ proofData: { vk, proof, publicSignals } });

    const txInfo = await transactionResult;

    // Store public signals with statement hash for later retrieval
    await db.query(
        `INSERT INTO pending_verifications (statement_hash, claimed_total, session_id, player_address)
         VALUES ($1, $2, $3, $4)`,
        [txInfo.statement, publicSignals[0], publicSignals[1], publicSignals[2]]
    );

    return { success: true, txHash: txInfo.txHash };
});

// When ProofVerified event fires:
async function handleProofVerified(eventData: any) {
    const { statement } = eventData;

    // Retrieve stored public signals
    const result = await db.query(
        'SELECT * FROM pending_verifications WHERE statement_hash = $1',
        [statement]
    );

    if (result.rows.length === 0) {
        console.error('No pending verification found for:', statement);
        return;
    }

    const { claimed_total, session_id, player_address } = result.rows[0];

    // Insert into leaderboard
    await db.query(
        `INSERT INTO leaderboard (player_address, score, session_id, tx_hash)
         VALUES ($1, $2, $3, $4)`,
        [player_address, claimed_total, session_id, statement]
    );

    // Clean up pending verification
    await db.query('DELETE FROM pending_verifications WHERE statement_hash = $1', [statement]);
}
```

### Frontend: Real-time Leaderboard Updates

Use WebSockets or polling to show real-time updates to players:

```typescript
// Backend: WebSocket endpoint
fastify.register(require('fastify-websocket'));

fastify.ready(err => {
    if (err) throw err;

    fastify.websocketServer.on('connection', (socket, req) => {
        socket.send(JSON.stringify({ type: 'connected' }));

        // Broadcast leaderboard updates
        zkSession.subscribe([
            {
                event: ZkVerifyEvents.ProofVerified,
                callback: async (eventData) => {
                    const leaderboard = await fetchLeaderboard();
                    socket.send(JSON.stringify({
                        type: 'leaderboard_update',
                        data: leaderboard
                    }));
                }
            }
        ]);
    });
});

// Frontend: Connect to WebSocket
const ws = new WebSocket('ws://localhost:3000/ws');

ws.onmessage = (event) => {
    const message = JSON.parse(event.data);

    if (message.type === 'leaderboard_update') {
        renderLeaderboard(message.data);
    }
};
```

### Handling Failed Verifications

You should also subscribe to error events:

```typescript
zkSession.subscribe([
        {
            event: ZkVerifyEvents.ProofVerified,
            callback: handleProofVerified
        },
        {
            event: 'ErrorEvent', // Generic error event
            callback: (error: any) => {
                console.error('zkVerify error:', error);
                // Notify admin or log to monitoring service
            }
        }
]);
```

### Production Considerations

1. **Persistence:**
   - Store event data for audit trails
   - Use a message queue (RabbitMQ, Redis) for reliability

2. **Idempotency:**
   - Handle duplicate events gracefully
   - Use unique constraints in your database

3. **Scaling:**
   - Run multiple instances with load balancing
   - Each instance can subscribe to all events
   - Use database constraints to prevent duplicates

4. **Monitoring:**
   - Track event processing latency
   - Set up alerts for missed events
   - Monitor database connection health

5. **Backup:**
   - Consider a polling fallback if WebSocket drops
   - Periodically query blockchain for missed verifications

## Usage Examples

### Example 1: cURL Command
```bash
curl -X POST http://localhost:3000/verify-score \
  -H "Content-Type: application/json" \
  -d '{
    "proof": {
      "pi_a": ["0x123...", "0x456"],
      "pi_b": [["0x789", "0xabc"], ["0xdef", "0x012"]],
      "pi_c": ["0x345", "0x678"],
      "protocol": "groth16",
      "curve": "bn128"
    },
    "publicSignals": ["150", "987654321", "0x1234567890abcdef1234567890abcdef12345678", "0xabcdef...", "1"]
  }'
```

### Example 2: JavaScript Fetch (Browser)
```javascript
const response = await fetch('http://localhost:3000/verify-score', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    proof: proofObject,      // From snarkjs.groth16.fullProve()
    publicSignals: publicArray
  })
});

const data = await response.json();
if (data.success) {
  console.log('Transaction Hash:', data.transactionHash);
  console.log('Explorer URL:', data.explorerUrl);
} else {
  console.error('Error:', data.error);
}
```

### Example 3: JavaScript Fetch (Node.js)
```javascript
import fetch from 'node-fetch';

const proofData = {
  proof: require('./proof.json'),
  publicSignals: require('./public.json')
};

const response = await fetch('http://localhost:3000/verify-score', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(proofData)
});

const data = await response.json();
console.log(data);
```

## Complete Workflows

### Workflow A: CLI (Command Line)
Use this for testing and development without the server.

1. Generate proof locally:
   ```bash
   snarkjs groth16 fullprove input.json circuits/score_prover_js/score_prover.wasm circuits/score_prover_final.zkey proof.json public.json
   ```

2. Submit to zkVerify:
   ```bash
   node scripts/verify_score.js
   ```

3. Monitor transaction on explorer using the returned transaction hash.

### Workflow B: Browser + Server (Production)
Use this for a real game application.

1. **Start the Backend Server**:
   ```bash
   npm run dev
   ```

2. **Open Browser Test Interface**:
   ```bash
   python3 -m http.server 8000
   # Then open http://localhost:8000/test.html
   ```

3. **Generate Proof in Browser**:
   - Enter your 5 level scores
   - Enter your secret (private)
   - Enter your player address (public)
   - Session ID is auto-generated
   - Click "Step 1: Generate ZK Proof"

4. **Submit to zkVerify**:
   - Click "Step 2: Submit to zkVerify"
   - The browser sends proof to backend server
   - Backend relays to zkVerify network
   - Receive transaction hash and explorer link

5. **Monitor on Leaderboard**:
   - Your app listens for zkVerify attestation events
   - Verify sessionId is unique
   - Update leaderboard with verified score

### Workflow C: Custom Integration
For your own game frontend:

```javascript
// 1. Player finishes game
const scores = [100, 200, 150, 300, 250];
const totalScore = scores.reduce((a, b) => a + b, 0);
const sessionId = Date.now().toString() + Math.floor(Math.random() * 1000);
const playerAddress = await getPlayerWalletAddress();
const secret = await getPlayerSecret();

// 2. Generate ZK proof
const input = {
  scores,
  secret: toBigInt(secret),
  claimedTotal: totalScore,
  sessionId: toBigInt(sessionId),
  playerAddress: toBigInt(playerAddress)
};

const { proof, publicSignals } = await snarkjs.groth16.fullProve(
  input,
  'circuits/score_prover_js/score_prover.wasm',
  'circuits/score_prover_final.zkey'
);

// 3. Submit to backend
const response = await fetch('http://localhost:3000/verify-score', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ proof, publicSignals })
});

const { transactionHash, explorerUrl } = await response.json();

// 4. Store pending score with transaction hash
await savePendingScore(playerAddress, totalScore, transactionHash, sessionId);

// 5. Backend monitors zkVerify for finalization
// When finalized, verify sessionId uniqueness and update leaderboard
```

### Workflow D: Unity WebGL Integration

For Unity games targeting WebGL platform, use the included C# wrapper and JavaScript bridge to generate ZK proofs directly in your game.

**Prerequisites:**
- Unity 2021.3 or later (WebGL build support)
- Target platform: WebGL

**Quick Example:**

```csharp
// 1. Attach ZKProverBridge.cs to a GameObject in your scene
// 2. Generate proof when game ends
public class GameManager : MonoBehaviour
{
    private int[] levelScores = new int[5];
    private string playerSecret = "your_player_secret";
    private string sessionId;

    void Start()
    {
        // Generate unique session ID for this game session
        sessionId = System.Guid.NewGuid().ToString();

        // Subscribe to proof generation events
        ZKProverBridge.Instance.OnProofGenerated += HandleProofGenerated;
    }

    public void SubmitScore()
    {
        string playerAddress = "0xYourWalletAddress";
        ZKProverBridge.Instance.GenerateScoreProof(levelScores, playerSecret, sessionId, playerAddress);
    }

    private void HandleProofGenerated(ZKProofResult result)
    {
        if (result.success)
        {
            // Send proof to your backend server (POST /verify-score)
            StartCoroutine(SubmitToBackend(result.proof, result.publicSignals));
        }
    }

    private IEnumerator SubmitToBackend(string proof, string[] publicSignals)
    {
        string jsonData = $"{{\"proof\": {proof}, \"publicSignals\": {JsonUtility.ToJson(publicSignals)}}}";

        using (UnityWebRequest request = UnityWebRequest.PostWwwForm("http://localhost:3000/verify-score", jsonData))
        {
            request.SetRequestHeader("Content-Type", "application/json");
            yield return request.SendWebRequest();

            if (request.result == UnityWebRequest.Result.Success)
            {
                Debug.Log("âœ… Proof submitted to zkVerify!");
            }
            else
            {
                Debug.LogError($"âŒ Submission failed: {request.error}");
            }
        }
    }
}
```

**Unity Integration Files:**

| File | Purpose | Location |
|------|---------|----------|
| `ZKProverBridge.cs` | C# wrapper for ZK proof generation | `unity/Scripts/` |
| `ZKProver.jslib` | JavaScript bridge to snarkjs | `unity/Plugins/WebGL/` |
| `score_prover.wasm` | Compiled circuit for witness generation | `unity/StreamingAssets/zk/` |
| `score_prover_final.zkey` | Proving key for proof generation | `unity/StreamingAssets/zk/` |

**Setup Steps:**

1. Copy `unity/` directory contents to your Unity project's `Assets/` folder
2. Include `snarkjs` in your WebGL template's `index.html`:
   ```html
   <script src="https://cdn.jsdelivr.net/npm/snarkjs@latest/build/snarkjs.min.js"></script>
   ```
3. Attach `ZKProverBridge.cs` to a GameObject in your scene
4. Add circuit files to `StreamingAssets/zk/`:
   - `score_prover.wasm`
   - `score_prover_final.zkey`
5. Build for WebGL platform

**ğŸ“– For detailed setup instructions, see: [unity/UNITY_SETUP.md](unity/UNITY_SETUP.md)**

**Notes:**
- Proof generation takes 2-5 seconds depending on device
- The `snarkjs` library is ~2MB - affects initial load time
- Show a loading indicator while generating proofs
- Circuit files must be in `StreamingAssets/zk/` for WebGL builds

## Running the Server

### Development Mode
```bash
npm run dev
```
Server runs on port 3000 (configurable via `PORT` environment variable).

### Production Build
```bash
npm run build
```
Compiles TypeScript to JavaScript in `dist/` directory.

## Verification Key Registration

By default, this project includes the full verification key with each proof submission. For production applications with high volume, you can **register your verification key on-chain** to reduce transaction costs and improve performance.

### When to Register Your VK

- **Development/Testing**: Not necessary - submit VK inline
- **Low-volume apps**: Optional - inline submission works fine
- **High-volume games**: Recommended - register once, submit many proofs with hash reference

### Registering the Verification Key

Use `registerVerificationKey()` method to upload your VK to zkVerify:

```typescript
import { zkVerifySession, Library, CurveType } from 'zkverifyjs';
import { getNetworkConfig, getSeedPhrase, Network } from './src/zkNetworkConfig';
import dotenv from 'dotenv';
import fs from 'fs';
dotenv.config();

async function setupRegisteredVK() {
    const networkConfig = getNetworkConfig();
    const network: Network = (process.env.ZKVERIFY_NETWORK as Network) || 'testnet';
    const seedPhrase = getSeedPhrase(network);

    // Start session
const session = await zkVerifySession.start()
    .Volta()
    .withAccount(seedPhrase);

// Load your verification key
const vkey = JSON.parse(fs.readFileSync('verification_key.json', 'utf8'));

// Register the verification key
const { events, transactionResult } = await session
    .registerVerificationKey()
    .groth16({
        library: Library.snarkjs,
        curve: CurveType.bn128
    })
    .execute(vkey);

// Wait for registration to complete
const vkTransactionInfo = await transactionResult;
console.log('âœ… Verification Key Registered!');
console.log('Statement Hash:', vkTransactionInfo.statementHash);
console.log('View on Explorer:', `${networkConfig.explorer}/vverify/transaction/${vkTransactionInfo.txHash}`);
```

### Submitting Proofs with Registered VK

Once registered, use `.withRegisteredVk()` and provide the `statementHash` instead of the full VK:

```typescript
// After registration, use the statement hash for all future proofs
const { events, transactionResult } = await session
    .verify()
    .groth16({
        library: Library.snarkjs,
        curve: CurveType.bn128
    })
    .withRegisteredVk() // Important: indicates VK is already registered
    .execute({
        proofData: {
            vk: vkTransactionInfo.statementHash, // Use hash, not full VK
            proof: proof,
            publicSignals: publicSignals
        },
        domainId: 0 // Optional domain ID for aggregation
    });
```

### Benefits of VK Registration

| Benefit | Inline VK | Registered VK |
|---------|-----------|---------------|
| Transaction Size | Large (includes full VK) | Small (only hash reference) |
| Transaction Cost | Higher | Lower |
| Setup Complexity | None | One-time registration |
| Use Case | Development, low volume | Production, high volume |

### Updating Your Server for Registered VKs

Modify `server.ts` to support registered VKs:

```typescript
// In your server.ts, load the statement hash from environment or config
const REGISTERED_VK_HASH = process.env.REGISTERED_VK_HASH; // e.g., "0xabc123..."

fastify.post('/verify-score', async (request, reply) => {
    const { proof, publicSignals } = request.body;

    const session = await zkVerifySession.start().Volta().withAccount(seedPhrase);

    const { transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .withRegisteredVk() // Use registered VK
        .execute({
            proofData: {
                vk: REGISTERED_VK_HASH, // Hash instead of full VK
                proof: proof,
                publicSignals: publicSignals
            }
        });

    // ... rest of your logic
});
```

### Complete Example: Register and Use VK

```typescript
import { zkVerifySession, Library, CurveType } from 'zkverifyjs';
import { getNetworkConfig, getSeedPhrase, Network } from './src/zkNetworkConfig';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
dotenv.config();

async function setupRegisteredVK() {
    const networkConfig = getNetworkConfig();
    const network: Network = (process.env.ZKVERIFY_NETWORK as Network) || 'testnet';
    const seedPhrase = getSeedPhrase(network);

    // Start session
    const session = await zkVerifySession.start()
        .Custom({
                websocket: networkConfig.websocket,
                rpc: networkConfig.rpc,
                network: network === 'mainnet' ? 'zkVerify' : 'Volta'
            })
        .withAccount(seedPhrase);

    // Load verification key
    const vkeyPath = path.join(__dirname, 'verification_key.json');
    const vkey = JSON.parse(fs.readFileSync(vkeyPath, 'utf8'));

    // Register VK
    console.log('ğŸ“ Registering verification key...');
    const { events, transactionResult } = await session
        .registerVerificationKey()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .execute(vkey);

    // Listen for events
    events.on('includedInBlock', (data) => {
        console.log('ğŸ“¦ VK registration included in block:', data.blockHash);
    });

    events.on('finalized', (data) => {
        console.log('âœ… VK registration finalized!');
        console.log('ğŸ“‹ Statement Hash:', data.statementHash);
        console.log('ğŸ”— Explorer:', `${networkConfig.explorer}/vverify/transaction/${data.txHash}`);
    });

    events.on('error', (error) => {
        console.error('âŒ Registration failed:', error);
    });

    // Wait for completion
    const result = await transactionResult;

    console.log('ğŸ‰ VK registered successfully!');
    console.log('Statement hash:', result.statementHash);
    console.log('Transaction hash:', result.txHash);

    // Save the statement hash for future use
    console.log('ğŸ’¾ Save this statement hash in your .env:');
    console.log(`REGISTERED_VK_HASH="${result.statementHash}"`);

    return result.statementHash;
}

// Run setup
setupRegisteredVK().catch(console.error);
```

### Managing Multiple Verification Keys

If your game uses different circuits for different modes:

```typescript
const VK_HASHES = {
    easyMode: process.env.VK_EASY,
    hardMode: process.env.VK_HARD,
    tournament: process.env.VK_TOURNAMENT
};

async function submitProofWithVK(proof, publicSignals, mode) {
    const vkHash = VK_HASHES[mode];

    const { transactionResult } = await session.verify()
        .groth16({ library: Library.snarkjs, curve: CurveType.bn128 })
        .withRegisteredVk()
        .execute({
            proofData: {
                vk: vkHash,
                proof: proof,
                publicSignals: publicSignals
            }
        });

    return await transactionResult;
}
```

## Network Configuration

This project supports switching between zkVerify testnet (Volta) and mainnet through environment variables.

### Quick Switch

**Default (Testnet):**
```bash
# Uses testnet (default if ZKVERIFY_NETWORK not set)
npm run dev
```

**Switch to Mainnet:**
```bash
# Option 1: Set environment variable
ZKVERIFY_NETWORK=mainnet npm run dev

# Option 2: Use convenience script
npm run dev:mainnet
```

**Verify on Testnet:**
```bash
ZKVERIFY_NETWORK=testnet node scripts/verify_score.js
# Or use convenience script:
npm run verify:testnet
```

**Verify on Mainnet:**
```bash
ZKVERIFY_NETWORK=mainnet node scripts/verify_score.js
# Or use convenience script:
npm run verify:mainnet
```

### Environment Variables

| Variable | Required | Description | Default |
|----------|-----------|-------------|----------|
| `ZKVERIFY_NETWORK` | No | Network: `testnet` or `mainnet` | `testnet` |
| `ZKVERIFY_TESTNET_SEED_PHRASE` | Yes (for testnet) | Seed phrase for Volta testnet wallet | - |
| `ZKVERIFY_MAINNET_SEED_PHRASE` | Yes (for mainnet) | Seed phrase for mainnet wallet | - |
| `ZKVERIFY_RPC_WSS` | No | Custom WebSocket RPC endpoint | - |
| `ZKVERIFY_RPC_HTTPS` | No | Custom HTTPS RPC endpoint | - |

### Network Details

| Network | Explorer | Faucet | Notes |
|---------|----------|--------|-------|
| **Testnet (Volta)** | [zkverify-testnet.subscan.io](https://zkverify-testnet.subscan.io) | [faucet.zkverify.io](https://faucet.zkverify.io/) | Free test tokens, for development |
| **Mainnet** | [zkverify.subscan.io](https://zkverify.subscan.io) | None | Real VFY tokens, production use |

### Using Ankr RPC (Recommended for Production)

Ankr provides higher rate limits and better reliability for production applications.

**Setup:**
1. Create a free account at [Ankr](https://www.ankr.com/web3-api/chains-list/zkverify/)
2. Get your API key
3. Add to your `.env`:

```bash
# Testnet with Ankr
ZKVERIFY_NETWORK=testnet
ZKVERIFY_TESTNET_SEED_PHRASE="your testnet seed phrase"
ZKVERIFY_RPC_WSS=wss://rpc.ankr.com/zkverify_volta_testnet/ws/YOUR_API_KEY
ZKVERIFY_RPC_HTTPS=https://rpc.ankr.com/zkverify_volta_testnet/YOUR_API_KEY
```

```bash
# Mainnet with Ankr
ZKVERIFY_NETWORK=mainnet
ZKVERIFY_MAINNET_SEED_PHRASE="your mainnet seed phrase"
ZKVERIFY_RPC_WSS=wss://rpc.ankr.com/zkverify_mainnet/ws/YOUR_API_KEY
ZKVERIFY_RPC_HTTPS=https://rpc.ankr.com/zkverify_mainnet/YOUR_API_KEY
```

**Benefits of Ankr:**
- Higher rate limits (no throttling under load)
- Better uptime and reliability
- Faster response times
- No additional cost for basic tier

### Security Best Practices

1. **Use different wallets for testnet and mainnet**
   ```bash
   # .env file
   ZKVERIFY_TESTNET_SEED_PHRASE="test wallet seed phrase..."
   ZKVERIFY_MAINNET_SEED_PHRASE="main wallet seed phrase..."
   ```

2. **Never commit seed phrases to version control**
   - `.env` is already in `.gitignore`
   - Keep `.env.example` as a template only

3. **Test on testnet first**
   - Verify proof generation works
   - Check proof submission flow
   - Confirm leaderboard integration
   - Only then switch to mainnet

### Example: Full Configuration

```bash
# .env - Mainnet configuration with Ankr
ZKVERIFY_NETWORK=mainnet
ZKVERIFY_MAINNET_SEED_PHRASE="your mainnet seed phrase here"
ZKVERIFY_RPC_WSS=wss://rpc.ankr.com/zkverify_mainnet/ws/YOUR_API_KEY
ZKVERIFY_RPC_HTTPS=https://rpc.ankr.com/zkverify_mainnet/YOUR_API_KEY
```

```bash
# .env - Testnet configuration
ZKVERIFY_NETWORK=testnet
ZKVERIFY_TESTNET_SEED_PHRASE="your testnet seed phrase here"
# Ankr optional for testnet
```

### Migration Guide

This project requires migration from the old single seed phrase configuration.

**Old configuration (no longer supported):**
```bash
# This will no longer work
ZKVERIFY_SEED_PHRASE="your seed phrase"
```

**New configuration (required):**
```bash
# Update to network-specific variables
ZKVERIFY_NETWORK=testnet
ZKVERIFY_TESTNET_SEED_PHRASE="your seed phrase"

# Also add mainnet configuration when ready:
ZKVERIFY_MAINNET_SEED_PHRASE="your mainnet seed phrase"
```

**Migration Steps:**
1. Open your `.env` file
2. Add `ZKVERIFY_NETWORK=testnet` (or `mainnet`)
3. Rename `ZKVERIFY_SEED_PHRASE` to either:
   - `ZKVERIFY_TESTNET_SEED_PHRASE` (for testnet)
   - `ZKVERIFY_MAINNET_SEED_PHRASE` (for mainnet)
4. Consider adding to other network configuration for future use

## Troubleshooting

### Common Issues

**"Invalid proof" or "Proof generation failed"**
- Check that all scores are < 1001
- Verify that `claimedTotal` equals the sum of scores
- Ensure all inputs are in correct format (bigints, hex strings, or numbers)

**"ZKVERIFY_TESTNET_SEED_PHRASE not found in environment" or "ZKVERIFY_MAINNET_SEED_PHRASE not found"**
- Create a `.env` file in the root directory
- Copy your seed phrase from `.env.example` and replace with your actual seed phrase
- Ensure `ZKVERIFY_NETWORK` is set to `testnet` or `mainnet`
- Ensure `.env` is in the project root (not in a subdirectory)

**"Transaction failed" or "Insufficient balance"**
- Check that your wallet has VFY testnet tokens
- Visit the [zkVerify faucet](https://faucet.zkverify.io/) to get testnet tokens
- Verify your wallet address is correct

**CORS errors (in production)**
- Update the CORS origin in `server.ts` line 14:
  ```typescript
  fastify.register(cors, {
      origin: 'https://your-game-domain.com', // Restrict to your domain
  });
  ```

**"Module not found" errors**
- Run `npm install` to install dependencies
- Ensure you're in the project root directory

**Circuit compilation errors**
- Ensure Circom compiler is installed correctly
- Check that `circomlib` is installed: `npm install circomlib`
- Verify circuit syntax matches pragma version `2.1.0`

## Security Best Practices

1. **Never hardcode seed phrases**
    - Always use network-specific environment variables (`ZKVERIFY_TESTNET_SEED_PHRASE`, `ZKVERIFY_MAINNET_SEED_PHRASE`)
    - Add `.env` to `.gitignore`
    - Never commit `.env` files to version control

2. **Use unique session IDs**
   - Generate unique session IDs per game session
   - Recommended format: timestamp + random number or UUID
   - Never reuse session IDs across different game sessions

3. **Store secrets securely on client**
   - Use `localStorage` or `sessionStorage` (not in plain text in code)
   - Consider encrypting the secret
   - Allow users to set and rotate their secret

4. **Verify attestations before updating leaderboard**
   - Always verify that sessionId hasn't been used before
   - Check that playerAddress matches the expected wallet
   - Only update leaderboard after zkVerify attestation is finalized

5. **Validate all inputs**
   - Validate score ranges on the backend (defensive programming)
   - Reject scores > 1000 per level
   - Verify wallet address format

6. **CORS configuration**
   - In production, restrict CORS to your game's domain only
   - Don't use `origin: '*'` in production environments

7. **Monitor zkVerify transactions**
   - Listen for `Attestation` events from zkVerify
   - Handle both `finalized` and `error` events
   - Implement retry logic for failed transactions

8. **Rate limiting**
   - Implement rate limiting on the backend to prevent abuse
   - Limit the number of proofs a player can submit per time period

## Replay Protection in Detail

### How Session ID Uniqueness Works

The `sessionId` is included in the proof's public signals, but **the circuit itself does not enforce uniqueness**. The **prevention of replay attacks happens in your backend/leaderboard logic**.

### Division of Responsibilities

| Component | Responsibility |
|-----------|----------------|
| **zkVerify Network** | Cryptographically verifies the proof is mathematically correct (sums match, secret known) |
| **Your Backend** | Prevents the same proof from being used twice by tracking sessionIds |

Without the backend's uniqueness check, a malicious player could reuse a valid proof multiple times to inflate their score.

### Normal Flow (Unique Session ID)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     1. Generate unique      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Player   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Browser   â”‚
â”‚             â”‚       sessionId: "17365...  â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â”‚ 2. Generate proof
                                                 â–¼
                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                           â”‚  SnarkJS    â”‚
                                           â”‚  (Client)   â”‚
                                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                  â”‚
                                                  â”‚ 3. Submit proof
                                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     4. Check: sessionId used?    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  zkVerify   â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  Backend    â”‚
â”‚   Network   â”‚                                    â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     5. NO â†’ Submit to zkVerify   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚       â”‚
                                                 â”‚       â”‚ 6. Get attestation
                                                 â–¼       â”‚
                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                                           â”‚  Leaderboardâ”‚â—€â”˜
                                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Replay Attack Scenario

**What a malicious player attempts:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     1. Generate proof      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Malicious  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Browser   â”‚
â”‚    Player   â”‚     sessionId: "17365...    â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â”‚ 2. Submit proof
                                                 â–¼
                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                           â”‚  Backend    â”‚
                                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                  â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ 3. Check: sessionId used?               â”‚
                              â”‚   Database query: SELECT * FROM scores  â”‚
                              â”‚   WHERE session_id = "17365..."          â”‚
                              â”‚   Result: NO rows found                  â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                    â”‚
                                                    â”‚ 4. NO â†’ Submit to zkVerify
                                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     5. Verify success     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  zkVerify   â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  Backend    â”‚
â”‚   Network   â”‚                            â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â”‚ 6. Store score + sessionId
                                                 â–¼
                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                           â”‚  Leaderboardâ”‚
                                           â”‚  Score: 1000 â”‚
                                           â”‚  sessionId:  â”‚
                                           â”‚  17365...   â”‚
                                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                  â”‚
                                                  â”‚ 7. âš ï¸ REUSE SAME PROOF âš ï¸
                                                  â”‚    sessionId: "17365..."
                                                  â–¼
                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                           â”‚  Backend    â”‚
                                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                  â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ 8. Check: sessionId used?               â”‚
                              â”‚   Database query: SELECT * FROM scores  â”‚
                              â”‚   WHERE session_id = "17365..."          â”‚
                              â”‚   Result: 1 row FOUND!                  â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                    â”‚
                                                    â”‚ 9. YES â†’ REJECT
                                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âŒ REPLAY ATTACK BLOCKED                                           â”‚
â”‚  Error: "Session ID already used - replay attack prevented"        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Backend SessionId Validation Code

**Important:** This validation must happen **before** submitting to zkVerify, or at minimum **before** updating the leaderboard.

#### Example: PostgreSQL Implementation

```javascript
import pg from 'pg';
const { Pool } = pg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

async function submitScore(playerAddress, score, sessionId, transactionHash) {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // 1. Check if sessionId has been used before
    const existingResult = await client.query(
      'SELECT id FROM scores WHERE session_id = $1 FOR UPDATE',
      [sessionId]
    );

    if (existingResult.rows.length > 0) {
      await client.query('ROLLBACK');
      throw new Error('Session ID already used - replay attack prevented');
    }

    // 2. Verify zkVerify attestation is valid
    const isValid = await verifyAttestation(transactionHash);
    if (!isValid) {
      await client.query('ROLLBACK');
      throw new Error('Invalid zkVerify attestation');
    }

    // 3. Check that playerAddress matches attestation
    const attestation = await getAttestationDetails(transactionHash);
    if (attestation.playerAddress !== playerAddress) {
      await client.query('ROLLBACK');
      throw new Error('Player address mismatch');
    }

    // 4. Store the score (with unique constraint on session_id)
    await client.query(
      `INSERT INTO scores 
       (player_address, score, session_id, tx_hash, created_at)
       VALUES ($1, $2, $3, $4, NOW())`,
      [playerAddress, score, sessionId, transactionHash]
    );

    await client.query('COMMIT');
    return { success: true, message: 'Score added to leaderboard' };

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Create table with unique constraint
/*
CREATE TABLE scores (
  id SERIAL PRIMARY KEY,
  player_address VARCHAR(42) NOT NULL,
  score INTEGER NOT NULL,
  session_id BIGINT NOT NULL UNIQUE,
  tx_hash VARCHAR(66) NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT NOW()
);
*/
```

#### Example: Redis/Memory Implementation (for testing)

```javascript
const usedSessionIds = new Set();

function isSessionIdUsed(sessionId) {
  return usedSessionIds.has(sessionId);
}

function markSessionIdUsed(sessionId) {
  usedSessionIds.add(sessionId);
}

async function submitScore(playerAddress, score, sessionId, transactionHash) {
  // 1. Check if sessionId has been used before
  if (isSessionIdUsed(sessionId)) {
    throw new Error('Session ID already used - replay attack prevented');
  }

  // 2. Verify zkVerify attestation
  const isValid = await verifyAttestation(transactionHash);
  if (!isValid) {
    throw new Error('Invalid zkVerify attestation');
  }

  // 3. Store the score
  await saveScoreToLeaderboard(playerAddress, score, sessionId, transactionHash);

  // 4. Mark sessionId as used
  markSessionIdUsed(sessionId);

  return { success: true, message: 'Score added to leaderboard' };
}
```

### What If You Don't Track SessionIds?

If you don't implement the uniqueness check in your backend:

```
âœ… Proof submitted â†’ zkVerify verifies â†’ Score added: 1000
âœ… Same proof submitted again â†’ zkVerify verifies â†’ Score added: 1000 (duplicate!)
âœ… Same proof submitted again â†’ zkVerify verifies â†’ Score added: 1000 (triple!)
...
âœ… Attacker submits 1000 times â†’ Score inflated: 1,000,000
```

This would be a **critical vulnerability** allowing infinite score inflation.

### Important Clarifications

**Session IDs do NOT prevent legitimate duplicate scores:**
- A player can legitimately score 1000 multiple times
- Each submission must have a **different sessionId**
- Example: Playing the game 5 times = 5 different sessionIds = 5 valid score entries

**The circuit does NOT enforce uniqueness:**
- The circuit only validates: scores sum to total, scores < 1001, secret known
- Uniqueness checking is **purely a backend responsibility**
- This is intentional - it keeps the circuit simple and efficient

**Why this design?**
- Circuits are expensive to compute - keep them minimal
- Backend database operations are fast - let them handle uniqueness
- zkVerify provides cryptographic proof of correctness
- Your backend provides guarantee of non-replay

### Integration with Server Endpoint

Update your `server.ts` to include sessionId validation:

```typescript
// After receiving transactionHash from zkVerify
async function handleZkVerifyFinalization(transactionHash, publicSignals) {
  const sessionId = publicSignals[1]; // sessionId is at index 1
  const playerAddress = publicSignals[2]; // playerAddress is at index 2

  // Check uniqueness before updating leaderboard
  if (await isSessionIdUsed(sessionId)) {
    console.error(`Duplicate sessionId detected: ${sessionId}`);
    return;
  }

  // Update leaderboard
  await addToLeaderboard({
    playerAddress,
    score: parseInt(publicSignals[0]), // claimedTotal at index 0
    sessionId,
    transactionHash
  });
}
```

## How it Works

The circuit ensures that the five hidden `scores` sum up exactly to the public `claimedTotal`. Any attempt to spoof the total without matching individual level scores will fail the ZK constraint. Once verified by zkVerify, you get a cryptographic attestation that the score is valid.

The security model works as follows:
1. **Player proves they know the secret** for their address (identity binding)
2. **Player proves the scores are valid** (sums to claimed total, each < 1001)
3. **Unique session ID prevents replay** (same proof can't be submitted twice)
4. **zkVerify network cryptographically verifies** the proof
5. **Attestation event confirms validity** (score can be added to leaderboard)
6. **Backend validates sessionId uniqueness** (ensures no duplicate submissions)

## Resources

- [zkVerify Documentation](https://docs.zkverify.io/)
- [zkVerify Testnet Explorer](https://zkverify-testnet.subscan.io/) (Volta)
- [zkVerify Mainnet Explorer](https://zkverify.subscan.io/)
- [Circom Documentation](https://docs.circom.io/)
- [SnarkJS Documentation](https://github.com/iden3/snarkjs)
- [zkVerify Testnet Faucet](https://faucet.zkverify.io/)
- [Ankr zkVerify RPC](https://www.ankr.com/web3-api/chains-list/zkverify/) (Recommended for production)
